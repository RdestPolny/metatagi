import streamlit as st
import pandas as pd
import requests
from bs4 import BeautifulSoup as bs
from concurrent.futures import ThreadPoolExecutor, as_completed
from openai import OpenAI

# ------------- USTAWIENIA STRONY ------------- #
st.set_page_config(page_title="Generator Metatag√≥w SEO", page_icon="üè∑Ô∏è", layout="wide")

# ------------- POBIERANIE DANYCH ------------- #
def get_product_data(url):
    """Scrapuje dane produktu ze strony."""
    headers = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
        'Accept-Language': 'pl-PL,pl;q=0.9,en-US;q=0.8,en;q=0.7',
    }
    try:
        response = requests.get(url, headers=headers, timeout=30)
        response.raise_for_status()
        soup = bs(response.text, 'html.parser')

        title_tag = soup.find('h1')
        title = title_tag.get_text(strip=True) if title_tag else ''

        # Pobieranie ISBN z sekcji szczeg√≥≈Ç√≥w
        isbn = ""
        details_div = soup.find("div", id="accordion-content__szczeg√≥≈Çy")
        if details_div:
            ul = details_div.find("ul", class_="bullet")
            if ul:
                for li in ul.find_all("li", class_="display-detail"):
                    li_text = li.get_text(strip=True)
                    if li_text.startswith("ISBN:"):
                        strong_tag = li.find("strong")
                        if strong_tag:
                            isbn = strong_tag.get_text(strip=True)
                        break

        details_text = ""
        description_text = ""

        # Logika scrapowania dla smyk.com
        if 'smyk.com' in url:
            smyk_desc_div = soup.find("div", attrs={"data-testid": "box-attributes__simple"})
            if smyk_desc_div:
                for p_tag in smyk_desc_div.find_all("p"):
                    if p_tag.find("span", string=lambda x: x and "Nr produktu:" in x):
                        p_tag.decompose()
                description_text = smyk_desc_div.get_text(separator="\n", strip=True)

            smyk_attributes_div = soup.find("div", class_="box-attributes__not-simple")
            if smyk_attributes_div:
                attributes_list = []
                items = smyk_attributes_div.find_all("div", class_="box_attributes__spec-item")
                for item in items:
                    label_tag = item.find("span", class_="box-attributes-list__label--L")
                    value_tag = item.find("span", class_="box-attributes-list__atribute--L")
                    if label_tag and value_tag:
                        label = label_tag.get_text(strip=True)
                        value = value_tag.get_text(strip=True)
                        if label and value:
                            attributes_list.append(f"{label}: {value}")
                
                if attributes_list:
                    details_text = "\n".join(attributes_list)
        
        # Uniwersalne scrapowanie dla innych stron
        if not description_text:
            details_div = soup.find("div", id="szczegoly") or soup.find("div", class_="product-features")
            if details_div:
                ul = details_div.find("ul", class_="bullet") or details_div.find("ul")
                if ul:
                    li_elements = ul.find_all("li")
                    details_list = [li.get_text(separator=" ", strip=True) for li in li_elements]
                    details_text = "\n".join(details_list)
            
            description_div = soup.find("div", class_="desc-container")
            if description_div:
                article = description_div.find("article")
                if article:
                    nested_article = article.find("article")
                    if nested_article:
                        description_text = nested_article.get_text(separator="\n", strip=True)
                    else:
                        description_text = article.get_text(separator="\n", strip=True)
                else:
                    description_text = description_div.get_text(separator="\n", strip=True)

        if not description_text:
            alt_desc_div = soup.find("div", id="product-description")
            if alt_desc_div:
                description_text = alt_desc_div.get_text(separator="\n", strip=True)

        description_text = " ".join(description_text.split())

        if not description_text and not details_text:
            return {
                'title': title,
                'isbn': isbn,
                'details': '',
                'description': '',
                'error': "Nie uda≈Ço siƒô pobraƒá danych produktu."
            }
        
        return {
            'title': title,
            'isbn': isbn,
            'details': details_text,
            'description': description_text,
            'error': None
        }
    except Exception as e:
        return {
            'title': '',
            'isbn': '',
            'details': '',
            'description': '',
            'error': f"B≈ÇƒÖd pobierania: {str(e)}"
        }

# ------------- GENEROWANIE METATAG√ìW ------------- #
def generate_meta_tags(product_data, client):
    """Generuje meta title i meta description."""
    try:
        title = product_data.get('title', '')
        details = product_data.get('details', '')
        description = product_data.get('description', '')
        
        # >>>>>>>>>>>>>>>>>>>>>> NOWY, RYGORYSTYCZNY PROMPT <<<<<<<<<<<<<<<<<<<<<< #
        system_prompt = """Jeste≈õ ekspertem SEO tworzƒÖcym metatagi e-commerce po polsku.

WYMAGANIA META TITLE:
- Maksymalnie 60 znak√≥w (w≈ÇƒÖcznie ze spacjami)
- Zacznij od najwa≈ºniejszego s≈Çowa kluczowego (nazwa typu produktu/kategoria)
- Dodaj 1‚Äì2 kluczowe cechy/parametry (np. materia≈Ç, liczba stron, wiek, format)
- U≈ºywaj TYLKO zwyk≈Çego my≈õlnika "-" (nie u≈ºywaj d≈Çugiego "‚Äî")
- BEZ kropek w meta title
- BEZ nazw sklep√≥w/brand√≥w, BEZ CTA, BEZ emoji

WYMAGANIA META DESCRIPTION:
- Maksymalnie 160 znak√≥w (w≈ÇƒÖcznie ze spacjami)
- Dok≈Çadnie DWA kr√≥tkie zdania informacyjne
- Wy≈ÇƒÖcznie neutralne fakty o produkcie; naturalne s≈Çowa kluczowe
- BEZ CTA i BEZ nazw sklep√≥w/brand√≥w
- Mo≈ºesz u≈ºyƒá obiektywnych parametr√≥w (np. ISBN, materia≈Ç, liczba stron), tylko je≈õli siƒô mieszczƒÖ

ZASADY DODATKOWE:
- Je≈õli brakuje danych, NIE halucynuj ‚Äì bazuj wy≈ÇƒÖcznie na przekazanym tytule/opisie/atrybutach
- Przed odpowiedziƒÖ mentalnie zweryfikuj limity d≈Çugo≈õci i to, ≈ºe opis ma dok≈Çadnie dwa zdania

FORMAT ODPOWIEDZI (dok≈Çadnie dwie linie):
Meta title: [tre≈õƒá]
Meta description: [tre≈õƒá]
Zwr√≥ƒá wy≈ÇƒÖcznie te dwie linie w tej kolejno≈õci."""

        user_prompt = f"""DANE PRODUKTU:
Tytu≈Ç: {title if title else 'brak'}
Szczeg√≥≈Çy (wybrane atrybuty, lista): {details[:600] if details else 'brak'}
Opis: {description[:900] if description else 'brak'}

Na podstawie powy≈ºszych danych stw√≥rz zoptymalizowane metatagi zgodnie z wymaganiami i formatem odpowiedzi."""
        # >>>>>>>>>>>>>>>>>>>>>> KONIEC ZMIAN W PROMPCIE <<<<<<<<<<<<<<<<<<<<<< #

        full_input = f"{system_prompt}\n\n{user_prompt}"

        response = client.responses.create(
            model="gpt-5-nano",
            input=full_input,
            reasoning={"effort": "medium"},
            text={"verbosity": "low"}
        )
        
        result = response.output_text
        meta_title = ""
        meta_description = ""
        
        for line in result.splitlines():
            line = line.strip()
            if line.lower().startswith("meta title:"):
                meta_title = line[len("meta title:"):].strip()
            elif line.lower().startswith("meta description:"):
                meta_description = line[len("meta description:"):].strip()
        
        # Zamiana d≈Çugiego my≈õlnika na zwyk≈Çy
        meta_title = meta_title.replace('‚Äî', '-')
        
        # Usuwanie kropek z meta title
        meta_title = meta_title.replace('.', '')
        
        # Walidacja d≈Çugo≈õci (zachowana jak w oryginale)
        if len(meta_title) > 60:
            meta_title = meta_title[:57] + "..."
        if len(meta_description) > 160:
            meta_description = meta_description[:157] + "..."
        
        return meta_title, meta_description
    except Exception as e:
        return f"B≈ÅƒÑD: {str(e)}", f"B≈ÅƒÑD: {str(e)}"

# ------------- PRZETWARZANIE R√ìWNOLEG≈ÅE ------------- #
def process_single_product(url, sku, client):
    """Przetwarza jeden produkt: scrapuje dane i generuje metatagi."""
    try:
        product_data = get_product_data(url)
        
        if product_data['error']:
            return {
                'url': url,
                'sku': sku,
                'title': product_data.get('title', ''),
                'isbn': product_data.get('isbn', ''),
                'meta_title': '',
                'meta_description': '',
                'error': product_data['error']
            }
        
        meta_title, meta_description = generate_meta_tags(product_data, client)
        
        if "B≈ÅƒÑD:" in meta_title:
            return {
                'url': url,
                'sku': sku,
                'title': product_data.get('title', ''),
                'isbn': product_data.get('isbn', ''),
                'meta_title': '',
                'meta_description': '',
                'error': meta_title
            }
        
        return {
            'url': url,
            'sku': sku,
            'title': product_data.get('title', ''),
            'isbn': product_data.get('isbn', ''),
            'meta_title': meta_title,
            'meta_description': meta_description,
            'meta_title_length': len(meta_title),
            'meta_desc_length': len(meta_description),
            'error': None
        }
    except Exception as e:
        return {
            'url': url,
            'sku': sku,
            'title': '',
            'isbn': '',
            'meta_title': '',
            'meta_description': '',
            'error': f"Nieoczekiwany b≈ÇƒÖd: {str(e)}"
        }

# ------------- INICJALIZACJA ------------- #
if 'results' not in st.session_state:
    st.session_state.results = []

if "OPENAI_API_KEY" not in st.secrets:
    st.error("‚ùå Brak klucza API OpenAI w secrets. Skonfiguruj OPENAI_API_KEY.")
    st.stop()

client = OpenAI()

# ------------- INTERFEJS U≈ªYTKOWNIKA ------------- #
st.title('üè∑Ô∏è Generator Metatag√≥w SEO - Tryb Wsadowy')
st.markdown("Wygeneruj zoptymalizowane meta title i meta description dla wielu produkt√≥w jednocze≈õnie.")

# Sidebar z informacjami
st.sidebar.header("üìä Limity SEO")
st.sidebar.metric("Meta Title", "max 60 znak√≥w")
st.sidebar.metric("Meta Description", "max 160 znak√≥w")
st.sidebar.markdown("---")
st.sidebar.info("üí° **Wskaz√≥wka:** Zielony status üü¢ oznacza poprawnƒÖ d≈Çugo≈õƒá, ≈º√≥≈Çty üü° przekroczenie limitu.")
st.sidebar.markdown("---")
st.sidebar.subheader("‚úÖ Standardy SEO")
st.sidebar.markdown("""
- **Meta Title:** Tylko zwyk≈Çy my≈õlnik "-"
- **Meta Title:** Bez nazwy sklepu/brandu
- **Meta Description:** 2 zdania informacyjne
- **Meta Description:** Bez CTA
- Skupienie na produkcie i jego warto≈õci
""")

# G≈Ç√≥wna zawarto≈õƒá
st.info("üìù Wklej linki do produkt√≥w i wygeneruj dla nich zoptymalizowane metatagi SEO.")

col1, col2 = st.columns([2, 1])

with col1:
    urls_input = st.text_area(
        "üîó Linki do produkt√≥w (jeden na liniƒô)",
        height=300,
        placeholder="https://example.com/produkt-1\nhttps://example.com/produkt-2\nhttps://example.com/produkt-3",
        key="urls"
    )

with col2:
    skus_input = st.text_area(
        "üè∑Ô∏è Kody SKU (opcjonalne, jeden na liniƒô)",
        height=300,
        placeholder="SKU-001\nSKU-002\nSKU-003",
        key="skus",
        help="Opcjonalne pole identyfikacyjne produktu"
    )

col_btn1, col_btn2 = st.columns([3, 1])

with col_btn1:
    if st.button("üöÄ Generuj metatagi", type="primary", use_container_width=True):
        urls = [url.strip() for url in urls_input.splitlines() if url.strip()]
        skus = [sku.strip() for sku in skus_input.splitlines() if sku.strip()]
        
        if not urls:
            st.error("‚ùå Podaj przynajmniej jeden link do produktu!")
        else:
            # Je≈õli SKU nie podano, uzupe≈Çnij pustymi stringami
            if len(skus) < len(urls):
                skus.extend([''] * (len(urls) - len(skus)))
            elif len(skus) > len(urls):
                st.warning(f"‚ö†Ô∏è Liczba SKU ({len(skus)}) jest wiƒôksza ni≈º link√≥w ({len(urls)}). Ignorujƒô nadmiarowe SKU.")
                skus = skus[:len(urls)]
            
            st.session_state.results = []
            
            progress_bar = st.progress(0, text="Rozpoczynam generowanie metatag√≥w...")
            
            with ThreadPoolExecutor(max_workers=5) as executor:
                future_to_data = {
                    executor.submit(process_single_product, url, sku, client): (url, sku)
                    for url, sku in zip(urls, skus)
                }
                
                results_temp = []
                for i, future in enumerate(as_completed(future_to_data)):
                    result = future.result()
                    results_temp.append(result)
                    progress_bar.progress(
                        (i + 1) / len(future_to_data),
                        text=f"Przetworzono {i+1}/{len(future_to_data)}"
                    )
            
            # Sortuj wed≈Çug kolejno≈õci oryginalnych URL-i
            st.session_state.results = sorted(results_temp, key=lambda x: urls.index(x['url']))
            progress_bar.progress(1.0, text="‚úÖ Zako≈Ñczono!")
            st.success(f"Wygenerowano metatagi dla {len(st.session_state.results)} produkt√≥w!")

with col_btn2:
    if st.button("üóëÔ∏è Wyczy≈õƒá", use_container_width=True):
        st.session_state.results = []
        st.rerun()

# Wy≈õwietlanie wynik√≥w
if st.session_state.results:
    st.markdown("---")
    st.header("üìä Wyniki")
    
    results = st.session_state.results
    successful = [r for r in results if r['error'] is None]
    errors = [r for r in results if r['error'] is not None]
    
    # Statystyki
    col1, col2, col3, col4 = st.columns(4)
    col1.metric("üîó Wszystkie", len(results))
    col2.metric("‚úÖ Sukces", len(successful))
    col3.metric("‚ùå B≈Çƒôdy", len(errors))
    
    if successful:
        avg_title_len = sum(r['meta_title_length'] for r in successful) / len(successful)
        avg_desc_len = sum(r['meta_desc_length'] for r in successful) / len(successful)
        col4.metric("üìè ≈ör. d≈Çugo≈õƒá title", f"{avg_title_len:.0f} zn.")
    
    # Eksport do CSV
    if successful:
        df = pd.DataFrame([
            {
                'URL': r['url'],
                'SKU': r['sku'],
                'ISBN': r['isbn'],
                'Tytu≈Ç produktu': r['title'],
                'Meta Title': r['meta_title'],
                'Meta Description': r['meta_description'],
                'D≈Çugo≈õƒá Title': r['meta_title_length'],
                'D≈Çugo≈õƒá Description': r['meta_desc_length']
            }
            for r in successful
        ])
        
        csv = df.to_csv(index=False).encode('utf-8')
        st.download_button(
            "üì• Pobierz wyniki jako CSV",
            csv,
            "metatagi_seo.csv",
            "text/csv",
            use_container_width=True
        )
    
    # Szczeg√≥≈Çowe wyniki - TABELA
    st.markdown("---")
    st.subheader("üìã Wyniki w formie tabeli")
    
    # Filtrowanie
    show_filter = st.radio(
        "Poka≈º:",
        ["Wszystkie", "Tylko sukces", "Tylko b≈Çƒôdy"],
        horizontal=True
    )
    
    if show_filter == "Tylko sukces":
        displayed_results = successful
    elif show_filter == "Tylko b≈Çƒôdy":
        displayed_results = errors
    else:
        displayed_results = results
    
    # Tworzenie tabeli dla wszystkich wynik√≥w
    if displayed_results:
        table_data = []
        for result in displayed_results:
            if result['error']:
                # Wiersz z b≈Çƒôdem
                table_data.append({
                    'Status': '‚ùå',
                    'SKU': result['sku'] if result['sku'] else '-',
                    'ISBN': result['isbn'] if result['isbn'] else '-',
                    'Meta Title': f"B≈ÅƒÑD: {result['error'][:50]}...",
                    'Meta Description': '-',
                    'D≈Çugo≈õƒá T': '-',
                    'D≈Çugo≈õƒá D': '-'
                })
            else:
                # Wiersz z sukcesem
                title_status = 'üü¢' if result['meta_title_length'] <= 60 else 'üü°'
                desc_status = 'üü¢' if result['meta_desc_length'] <= 160 else 'üü°'
                
                table_data.append({
                    'Status': f"{title_status}{desc_status}",
                    'SKU': result['sku'] if result['sku'] else '-',
                    'ISBN': result['isbn'] if result['isbn'] else '-',
                    'Meta Title': result['meta_title'],
                    'Meta Description': result['meta_description'],
                    'D≈Çugo≈õƒá T': f"{result['meta_title_length']}/60",
                    'D≈Çugo≈õƒá D': f"{result['meta_desc_length']}/160"
                })
        
        df_display = pd.DataFrame(table_data)
        
        # Konfiguracja wy≈õwietlania kolumn
        st.dataframe(
            df_display,
            use_container_width=True,
            hide_index=True,
            column_config={
                "Status": st.column_config.TextColumn("", width="small"),
                "SKU": st.column_config.TextColumn("SKU", width="small"),
                "ISBN": st.column_config.TextColumn("ISBN", width="small"),
                "Meta Title": st.column_config.TextColumn("Meta Title", width="large"),
                "Meta Description": st.column_config.TextColumn("Meta Description", width="large"),
                "D≈Çugo≈õƒá T": st.column_config.TextColumn("D≈Ç. T", width="small"),
                "D≈Çugo≈õƒá D": st.column_config.TextColumn("D≈Ç. D", width="small"),
            }
        )

# Stopka
st.markdown("---")
st.markdown("üîß **Generator Metatag√≥w SEO** | Powered by OpenAI GPT-5-nano")
